/*
* Graph.c
*
*  Created on: May 21, 2013
*      Author: Juan Manzo
*/

#include <stdio.h>
#include <stdlib.h>
#include "List.h"
#include "Graph.h"

typedef struct Graph{
    /* Fields */
    int order;
    int size;
    int source;
    char *color;
    int *distance;
    int *parent;
    ListRef *adj;

} Graph;

/* Constructor/Destructor */

GraphRef newGraph(int n){
    int i;
    /* Allocate memory blocks */
    GraphRef G = malloc(sizeof(Graph));
    G->color = calloc(n + 1, sizeof(char));
    G->distance = calloc(n + 1, sizeof(int));
    G->parent = calloc(n + 1, sizeof(int));
    G->adj = calloc(n + 1, sizeof(ListRef));

    /* Initialize fields */
    G->order = n;
    G->size = 0;
    G->source = 0;

    /* Index will start at 1 to correlate with graph vertex labels */
    for (i = 0; i < n; ++i) {
        /* w symbolizes state of vertex. initially all will be w (white) */
        G->color[i] = 'w';
        G->distance[i] = INF;
        G->parent[i] = NIL;
        G->adj[i] = newList();
    }

    return G;
}

void freeGraph(GraphRef* pG){
    int i;

    for(i = 0; i < getOrder(*pG); i++){
        /*free all lists in the Graph*/
        freeList(&((*pG)->adj[i] ) );
    }

    /*free fields*/
    free(((*pG)->parent));
    free(((*pG)->distance));
    free((*pG)->color);

    /*free pointers to fields*/
    (*pG)->parent = NULL;
    (*pG)->distance = NULL;
    (*pG)->color = NULL;

    free(*pG);
    *pG = NULL;
}

/* Access functions */
int getOrder(GraphRef G) {
    /* Returns the order of the Graph. Pre: Graphref != NULL */
    if(G == NULL) {
        printf("Graph Error: Calling getOrder() on NULL GraphRef \n");
        exit(1);
    }

    return (G->order);
}

int getSize(GraphRef G) {
    /* Returns the size of the Graph. Pre: Graphref != NULL */
    if(G == NULL){
        printf("Graph Error: Calling getSize() on NULL GraphRef \n");
        exit(1);
    }

    return (G->size);
}

int getSource(GraphRef G) {
    /* Returns the source of the Graph. Pre: Graphref != NULL */
    if(G == NULL) {
        printf("Graph Error: Calling getSource() on NULL GraphRef \n");
        exit(1);
    }

    return (G->source);
}

int getParent(GraphRef G, int u) {
    /* Returns the parent of the vertex u. Pre: Graphref != NULL  1<= u <=GetOrder(G) */
    if(G == NULL) {
        printf("Graph Error: Calling getParent() on NULL GraphRef\n");
        exit(1);
    }

    if(u < 0 || u > getOrder(G)) {
        printf("%s%d%s", "Graph error: getParent() error, paremeter u must be between 1 and ", getOrder(G), " inclusive");
        exit(1);
    }

    return (G->parent[u]);
}

int getDist(GraphRef G, int u) {
    /* Returns the distance from source of the vertex u. Pre: Graphref != NULL and 1<= u <=GetOrder(G) */
    if(G == NULL) {
        printf("Graph Error: Calling getDist() on NULL GraphRef\n");
        exit(1);
    }

    if(u < 0 || u > getOrder(G)) {
        printf("%s%d%s", "Graph error: getDist() error, paremeter u must be between 1 and ", getOrder(G), " inclusive");
        exit(1);
    }

    return (G->distance[u]);
}

void getPath(ListRef L, GraphRef G, int u) {
    /* Pre: getSource(G)!=NIL and 1<= u <=GetOrder(G) */
    int i;

    if(getSource(G) == NIL){
        return;
    }

    if(u < 0 || u > getOrder(G)) {
        printf("%s%d%s", "Graph error: getPath() error, paremeter u must be between 1 and ", getOrder(G), " inclusive");
        exit(1);
    } else {
        /*Start at our vertex u, store that value and "climb" up the "tree" generated by BFS()  */
        int x = getParent(G, u);

        for(i = 0; i < getDist(G, u) - 1; i++ ) {
            insertBeforeFirst(L, x);
            x = getParent(G, x);
        }

        insertBeforeFirst(L, G->source);
        insertAfterLast(L, u);
        }

}

/*** Manipulation procedures ***/
void printPath(GraphRef G, ListRef L){
    /* Prints the path of the current source to getLast(L) which is u */
    moveFirst(L);
    if(getSource(G) != NIL){

    if(getLast(L) == G->source) {
        /*The vertex is teh same as the G's current source */
        printf("\n%s%d%s%d%s%d%s", "To get from ", G->source, " to ", getLast(L), " requires ", getDist(G, getLast(L)), " edges, ");
        printf("%s", " follow the path: ");
    } else if (G->parent[getLast(L)] == NIL ) {
        /*u has no parent, therefore there is no possible path from source to u */
        printf("\n%s%d%s%d%s\n", "There is no path from ", G->source, " to ", getLast(L), " in the graph.");
    } else {
        printf("\n%s%d%s%d%s%d%s", "To get from ", G->source, " to ", getLast(L), " requires  " , getDist(G,getLast(L)), " edges, ");
        printf( "%s", "follow the path: ");

    if(!offEnd(L) && !isEmpty(L)){
        while (!offEnd(L) && !isEmpty(L)) {

            printf("%d ", getCurrent(L));
            moveNext(L);
        }
        printf("\n");
    }
     }
        makeEmpty(L);}
    else
        return;
}

void makeNull(GraphRef G) {
    /* Pre: != NULL */

    if(G == NULL) {
        printf("Graph Error: Calling makeNULL() on already NULL GraphRef \n");
        exit(1);
    }

    int i;

    for(i = 0; i < getOrder(G); i++){
        while (!isEmpty(G->adj[i])) {
            makeEmpty(G->adj[i]);
        }
    }
    G = NULL;



}

void addEdge(GraphRef G, int u, int v) {
    /*u and v must both be between 0 to getOrder() inclusively.  */
	if(u > getOrder(G) || u < 0 || v < 0 || v > getOrder(G)){
		printf("Graph Error: Calling addEdge with incorrect parameter values. Must be > 0 and < order of G.\n");
		exit(1);
	}

	if(getLength(G->adj[u]) != 0){

        moveFirst((G->adj[u]));

        while(!offEnd(G->adj[u])){
            if(getCurrent(G->adj[u]) < v){
                insertAfterLast(G->adj[u], v);
                break;
            } else {
                insertBeforeCurrent(G->adj[u],v);
                break;
            }
        }

	} else {
        /* adjency list is empty, just insert to front */
		insertBeforeFirst(G->adj[u], v);
	}

}

void BFS(GraphRef G, int s) {
    ListRef Q = newList();
    G->source = s;
	int v;
	int i;
	int j;

	for (i = 0; i < G->order; i++){
		G->color[i] = 'w';
		G->distance[i] = INF;
		G->parent[i] = NIL;
	}

	G->color[s] = 'g';
	G->distance[s] = 0;
	G->parent[s] = NIL;

    /*add our source to the "stack"*/
	insertAfterLast(Q, s);

	while (!isEmpty(Q) && !offEnd(Q)){
		int u = getFirst(Q);
        deleteFirst(Q);
		moveFirst(G->adj[u]);

		for(j = 0; j < getLength(G->adj[u]); j++) {

			v = getCurrent(G->adj[u]);

			if (G->color[v] == 'w'){
                /*vertex not yet discovered*/
				G->color[v] = 'g';
				G->distance[v] = G->distance[u] + 1;
				G->parent[v] = u;
				insertAfterLast(Q, v);
				moveNext(G->adj[u]);
			} else {
                /*Already discovered this vertex, move to the next one.*/
                moveNext(G->adj[u]);
            }
		}
        /*done with the adjency list of u, color it black*/
		G->color[u] = 'b';
	}

    freeList(&Q);
    Q = NULL;

}



